# bash completion
_SMURF_SCRIPT_DIR="$(cat ~/.smurf/script_dir.txt)"
_SMURF_SUBCOMMANDS=$(python3 -c "import smurf._command_line_; print(' '.join(smurf._command_line_.available_scripts()))")
_SMURF_SUBCOMMANDS_FILES=$(python3 -c "import smurf._command_line_; print(' '.join(smurf._command_line_.available_scripts(filenames=True)))")

_smurf_autocomplete() {
  local i=1 cmd

  # find the subcommand
  while [[ "$i" -lt "$COMP_CWORD" ]]
  do
    local s="${COMP_WORDS[i]}"
    case "$s" in
      -*) ;;
      *)
        cmd="$s"
        break
        ;;
    esac
    (( i++ ))
  done

  if [[ "$i" -eq "$COMP_CWORD" ]]
  then
    local cur="${COMP_WORDS[COMP_CWORD]}"
    #COMPREPLY=($(compgen -W "plain subcommand subcommand2 --class-opt -h --help help" -- "$cur"))
	COMPREPLY=($(compgen -W "$_SMURF_SUBCOMMANDS" -- "$cur"))
    return # return early if we're still completing the 'current' command
  fi

  # we've completed the 'current' command and now need to call the next completion function
  # subcommands have their own completion functions
  FILENAME="$(ls $_SMURF_SCRIPT_DIR | grep ^$cmd)"
  extension="${FILENAME##*.}"
  if [[ "$extension" == "py" ]]; then
	  _python_argcomplete "$_SMURF_SCRIPT_DIR/$cmd.py"
  else
	  case "$cmd" in
		  start|build) _smurf_autocomplete_tarfiles ;;
		  *) _smurf_autocomplete_default ;;
	  esac
  fi
}

_smurf_autocomplete_default () {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    words="$_SMURF_SUBCOMMANDS"

    COMPREPLY=( $(compgen -o default -- ${cur}) )
    return 0
}

_smurf_autocomplete_tarfiles () {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    words="$_SMURF_SUBCOMMANDS"

    COMPREPLY=( $(compgen -W "$(ls | grep *.tgz)" -- ${cur}) )
    return 0
}

# code generated by the register-python-argcomplete command
# of the python argcompletion package
__python_argcomplete_run() {
    if [[ -z "$_ARC_DEBUG" ]]; then
        python3 "$@" 8>&1 9>&2 1>/dev/null 2>&1
    else
		echo "run $@ with python3"
        python3 "$@" 8>&1 9>&2 1>&9 2>&1
    fi
}

# code generated by the register-python-argcomplete command
# of the python argcompletion package
# modified to work with the smurf command in front
_python_argcomplete() {
    local IFS=$'\013'
    local SUPPRESS_SPACE=0
    if compopt +o nospace 2> /dev/null; then
        SUPPRESS_SPACE=1
    fi
	# strip the leading 'smurf' and adjust position in string
	# to enable compatibility with argcomplete
	NEW_LINE="$(echo $COMP_LINE | cut -d ' ' -f2-)"
	LENGTH_DIFFERENCE=$((${#COMP_LINE}-${#NEW_LINE}))
	NEW_POINT=$(($COMP_POINT-$LENGTH_DIFFERENCE))
	COMP_LINE="$NEW_LINE"
	COMP_POINT="$NEW_POINT"
	# modification ends
	COMPREPLY=( $(IFS="$IFS" \
					 COMP_LINE="$COMP_LINE" \
					 COMP_POINT="$COMP_POINT" \
					 COMP_TYPE="$COMP_TYPE" \
					 _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS" \
					 _ARGCOMPLETE=1 \
					 _ARGCOMPLETE_SUPPRESS_SPACE=$SUPPRESS_SPACE \
					 __python_argcomplete_run "$1") )
    if [[ $? != 0 ]]; then
        unset COMPREPLY
    elif [[ $SUPPRESS_SPACE == 1 ]] && [[ "$COMPREPLY" =~ [=/:]$ ]]; then
        compopt -o nospace
    fi
}

if [[ -n "$(ps -p $$ | grep zsh)" ]]; then
  autoload bashcompinit
  bashcompinit
fi

complete -F _smurf_autocomplete smurf
